(window.webpackJsonp=window.webpackJsonp||[]).push([[41],{458:function(n,a,e){"use strict";e.r(a);var s=e(0),r=Object(s.a)({},(function(){var n=this,a=n.$createElement,e=n._self._c||a;return e("ContentSlotsDistributor",{attrs:{"slot-key":n.$parent.slotKey}},[e("h4",{attrs:{id:"一句话用来指定this的环境"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#一句话用来指定this的环境"}},[n._v("#")]),n._v(" 一句话用来指定this的环境")]),n._v(" "),e("pre",[e("code",[n._v('var a = {\n    user:"追梦子",\n    fn:function(){\n        console.log(this.user);\n    }\n}\nvar b = a.fn;//特别注意一点 a.fn赋值给b的时候没有调用 调用 调用 调用 调用\nb(); //undefined\n\nvar a = {\n    user:"追梦子",\n    fn:function(){\n        console.log(this.user);\n    }\n}\na.fn(); //追梦子\n')])]),n._v(" "),e("h4",{attrs:{id:"_1、call"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_1、call"}},[n._v("#")]),n._v(" 1、call()")]),n._v(" "),e("pre",[e("code",[n._v('var a = {\n    user:"追梦子",\n    fn:function(){\n        console.log(this.user); //追梦子\n    }\n}\nvar b = a.fn;\nb.call(a);\n')])]),n._v(" "),e("p",[n._v("通过在call方法，给第一个参数添加要把b添加到哪个环境中，简单来说，this就会指向那个对象。")]),n._v(" "),e("p",[n._v("call方法除了第一个参数以外还可以添加多个参数，如下：")]),n._v(" "),e("pre",[e("code",[n._v('var a = {\n    user:"追梦子",\n    fn:function(e,ee){\n        console.log(this.user); //追梦子\n        console.log(e+ee); //3\n    }\n}\nvar b = a.fn;\nb.call(a,1,2);\n')])]),n._v(" "),e("h4",{attrs:{id:"_2、apply-同样apply也可以有多个参数，但是不同的是，第二个参数必须是一个数组"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_2、apply-同样apply也可以有多个参数，但是不同的是，第二个参数必须是一个数组"}},[n._v("#")]),n._v(" 2、apply()同样apply也可以有多个参数，但是不同的是，第二个参数必须是一个数组")]),n._v(" "),e("pre",[e("code",[n._v('var a = {\n    user:"追梦子",\n    fn:function(e,ee){\n        console.log(this.user); //追梦子\n        console.log(e+ee); //11\n    }\n}\nvar b = a.fn;\nb.apply(a,[10,1]);\n\nvar a = {\n    user:"追梦子",\n    fn:function(e,ee){\n        console.log(this.user); //追梦子\n        console.log(e+ee); //520\n    }\n}\nvar b = a.fn;\nvar arr = [500,20];\nb.apply(a,arr);\n')])]),n._v(" "),e("p",[n._v("//注意如果call和apply的第一个参数写的是null，那么this指向的是window对象")]),n._v(" "),e("pre",[e("code",[n._v('var a = {\n    user:"追梦子",\n    fn:function(){\n        console.log(this); //Window {external: Object, chrome: Object, document: document, a: Object, speechSynthesis: SpeechSynthesis…}\n    }\n}\nvar b = a.fn;\nb.apply(null);\n')])]),n._v(" "),e("h4",{attrs:{id:"_3、bind"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_3、bind"}},[n._v("#")]),n._v(" 3、bind()")]),n._v(" "),e("pre",[e("code",[n._v('var a = {\n    user:"追梦子",\n    fn:function(){\n        console.log(this.user);\n    }\n}\nvar b = a.fn;\nb.bind(a);\n')])]),n._v(" "),e("p",[n._v("我们发现代码没有被打印，对，这就是bind和call、apply方法的不同，实际上bind方法返回的是一个修改过后的函数。")]),n._v(" "),e("pre",[e("code",[n._v('var a = {\n    user:"追梦子",\n    fn:function(){\n        console.log(this.user);\n    }\n}\nvar b = a.fn;\nvar c = b.bind(a);\nconsole.log(c); //function() { [native code] }\n')])]),n._v(" "),e("p",[n._v("那么我们现在执行一下函数c看看，能不能打印出对象a里面的user")]),n._v(" "),e("pre",[e("code",[n._v('var a = {\n    user:"追梦子",\n    fn:function(){\n        console.log(this.user); //追梦子\n    }\n}\nvar b = a.fn;\nvar c = b.bind(a);\nc();\n')])]),n._v(" "),e("p",[n._v("bind方法和call、apply方法有些不同，但是不管怎么说它们都可以用来改变this的指向。")]),n._v(" "),e("p",[n._v("ok，同样bind也可以有多个参数，并且参数可以执行的时候再次添加，但是要注意的是，参数是按照形参的顺序进行的。")]),n._v(" "),e("p",[n._v('var a = {\nuser:"追梦子",\nfn:function(e,d,f){\nconsole.log(this.user); //追梦子\nconsole.log(e,d,f); //10 1 2\n}\n}\nvar b = a.fn;\nvar c = b.bind(a,10);\nc(1,2);')]),n._v(" "),e("p",[n._v("总结：call和apply都是改变上下文中的this并立即执行这个函数，bind方法可以让对应的函数想什么时候调就什么时候调用，并且可以将参数在执行的时候添加，这是它们的区别，根据自己的实际情况来选择使用。")])])}),[],!1,null,null,null);a.default=r.exports}}]);