(window.webpackJsonp=window.webpackJsonp||[]).push([[42],{460:function(n,e,o){"use strict";o.r(e);var s=o(0),t=Object(s.a)({},(function(){var n=this,e=n.$createElement,o=n._self._c||e;return o("ContentSlotsDistributor",{attrs:{"slot-key":n.$parent.slotKey}},[o("p",[n._v("情况1：如果一个函数中有this，但是它没有被上一级的对象所调用，那么this指向的就是window，这里需要说明的是在js的严格版中this指向的不是window，但是我们这里不探讨严格版的问题，你想了解可以自行上网查找。")]),n._v(" "),o("pre",[o("code",[n._v('function a(){\n    var user = "追梦子";\n    console.log(this.user); //undefined\n    console.log(this); //Window\n}\na();\n')])]),n._v(" "),o("p",[n._v("情况2：如果一个函数中有this，这个函数有被上一级的对象所调用，那么this指向的就是上一级的对象。")]),n._v(" "),o("pre",[o("code",[n._v('var o = {\n    user:"追梦子",\n    fn:function(){\n        console.log(this.user);  //追梦子\n    }\n}\no.fn();\n')])]),n._v(" "),o("p",[n._v("这里的this指向的是对象o，因为你调用这个fn是通过o.fn()执行的，那自然指向就是对象o，这里再次强调一点，this的指向在函数创建的时候是决定不了的，在调用的时候才能决定，谁调用的就指向谁，一定要搞清楚这个。")]),n._v(" "),o("p",[n._v("情况3：如果一个函数中有this，这个函数中包含多个对象，尽管这个函数是被最外层的对象所调用，this指向的也只是它上一级的对象")]),n._v(" "),o("pre",[o("code",[n._v("var o = {\n    a:10,\n    b:{\n        a:12,\n        fn:function(){\n            console.log(this.a); //12\n        }\n    }\n}\no.b.fn();\n")])]),n._v(" "),o("p",[n._v("情况4：")]),n._v(" "),o("pre",[o("code",[n._v("var o = {\n    a:10,\n    b:{\n        a:12,\n        fn:function(){\n            console.log(this.a); //undefined\n            console.log(this); //window\n        }\n    }\n}\nvar j = o.b.fn;\nj();\n")])]),n._v(" "),o("p",[n._v("这里this指向的是window，是不是有些蒙了？其实是因为你没有理解一句话，这句话同样至关重要。　　this永远指向的是最后调用它的对象，也就是看它执行的时候是谁调用的，例子4中虽然函数fn是被对象b所引用，但是在将fn赋值给变量j的时候并没有执行所以最终指向的是window，这和例子3是不一样的，例子3是直接执行了fn。")]),n._v(" "),o("p",[n._v("情况5：构造函数版this")]),n._v(" "),o("pre",[o("code",[n._v('function Fn(){\n    this.user = "追梦子";\n}\nvar a = new Fn();\nconsole.log(a.user); //追梦子\n')])]),n._v(" "),o("p",[n._v("这里之所以对象a可以点出函数Fn里面的user是因为new关键字可以改变this的指向，将这个this指向对象a，为什么我说a是对象，因为用了new关键字就是创建一个对象实例，理解这句话可以想想我们的例子3，我们这里用变量a创建了一个Fn的实例（相当于复制了一份Fn到对象a里面），此时仅仅只是创建，并没有执行，而调用这个函数Fn的是对象a，那么this指向的自然是对象a，那么为什么对象a中会有user，因为你已经复制了一份Fn函数到对象a中，用了new关键字就等同于复制了一份。")]),n._v(" "),o("p",[n._v("情况6：当this碰到return时")]),n._v(" "),o("pre",[o("code",[n._v("function fn()\n{\n    this.user = '追梦子';\n    return {};\n}\nvar a = new fn;\nconsole.log(a.user); //undefined\n\nfunction fn()\n{\n    this.user = '追梦子';\n    return function(){};\n}\nvar a = new fn;\nconsole.log(a.user); //undefined\n\nfunction fn()\n{\n    this.user = '追梦子';\n    return 1;\n}\nvar a = new fn;\nconsole.log(a.user); //追梦子\n\nfunction fn()\n{\n    this.user = '追梦子';\n    return undefined;\n}\nvar a = new fn;\nconsole.log(a.user); //追梦子\n")])]),n._v(" "),o("p",[n._v("如果返回值是一个对象，那么this指向的就是那个返回的对象，如果返回值不是一个对象那么this还是指向函数的实例。")]),n._v(" "),o("p",[n._v("还有一点就是虽然null也是对象，但是在这里this还是指向那个函数的实例，因为null比较特殊。")]),n._v(" "),o("pre",[o("code",[n._v("function fn()\n{\n    this.user = '追梦子';\n    return null;\n}\nvar a = new fn;\nconsole.log(a.user); //追梦子\n")])]),n._v(" "),o("p",[n._v("1.在严格版中的默认的this不再是window，而是undefined。")])])}),[],!1,null,null,null);e.default=t.exports}}]);